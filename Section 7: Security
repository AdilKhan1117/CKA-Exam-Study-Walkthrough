Security Primitives:
!
!
- Root based disabled
- Password based authentication disabled
- kube-apiserver first line of defence, controlling access to api-server itself

Authentication:
who can access the api-server? 
- Username and password stored in file
- username and tokens 
- cert
- LDAP
- Service accounts

Authorisation:
What can they do
- RBAC Authorisation
- ABAC Authorisation
- Node Authorisation 
- Webhook Mode

- All components talking to Kube-Api Server is secured via tls encryption 
- communicaton between application, pod within the cluster, can access all other pods within the cluster
  can restrict using network policies 
  
  Authentication:
  
  Access to K8s cluster:
  Admin - Users
  Developers - Users
  End users
  Bots - Service accounts since this is 3rd party
  
  - k8s does not manage users account nativlely 
  - cannot create users on clusters
  
  - Can create service accounts however for bots etc
  
  user access:
  
  - All user access is managed by the kubernetes api-server 
  - Api servers authenticate users before processing
  - kube-apiserver authenticates 
    - static password file = create user/passwords in csv file, can assign groups also 
    - static token file    = 
    - certificates
    - identity services
  
 Article on Setting up Basic Authentication
Setup basic authentication on Kubernetes (Deprecated in 1.19)
Note: This is not recommended in a production environment. This is only for learning purposes. Also note that this approach is deprecated in Kubernetes version 1.19 and is no longer available in later releases

Follow the below instructions to configure basic authentication in a kubeadm setup.

Create a file with user details locally at /tmp/users/user-details.csv

# User File Contents
password123,user1,u0001
password123,user2,u0002
password123,user3,u0003
password123,user4,u0004
password123,user5,u0005


Edit the kube-apiserver static pod configured by kubeadm to pass in the user details. The file is located at /etc/kubernetes/manifests/kube-apiserver.yaml



apiVersion: v1
kind: Pod
metadata:
  name: kube-apiserver
  namespace: kube-system
spec:
  containers:
  - command:
    - kube-apiserver
      <content-hidden>
    image: k8s.gcr.io/kube-apiserver-amd64:v1.11.3
    name: kube-apiserver
    volumeMounts:
    - mountPath: /tmp/users
      name: usr-details
      readOnly: true
  volumes:
  - hostPath:
      path: /tmp/users
      type: DirectoryOrCreate
    name: usr-details


Modify the kube-apiserver startup options to include the basic-auth file



apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  name: kube-apiserver
  namespace: kube-system
spec:
  containers:
  - command:
    - kube-apiserver
    - --authorization-mode=Node,RBAC
      <content-hidden>
    - --basic-auth-file=/tmp/users/user-details.csv
Create the necessary roles and role bindings for these users:



---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""] # "" indicates the core API group
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
 
---
# This role binding allows "jane" to read pods in the "default" namespace.
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: read-pods
  namespace: default
subjects:
- kind: User
  name: user1 # Name is case sensitive
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role #this must be Role or ClusterRole
  name: pod-reader # this must match the name of the Role or ClusterRole you wish to bind to
  apiGroup: rbac.authorization.k8s.io
Once created, you may authenticate into the kube-api server using the users credentials

curl -v -k https://localhost:6443/api/v1/pods -u "user1:password123"
  
 TLS Introduction:
 TLS Certificates PRE-REQ:
 
 - User access web server, comminication between user and server is encrypted this is TLS
 - Encrypt data using encrption keys, data is sent to server from client, cause this is encrypted
   it cannot be deencrypted by attacker however the key can since it is symmatric key and not assemtric
   since the client sends the key to the server. Same key to encrypt and decrypt 
   
 - Assmmetric, different keys to encrypt and dencrypt
 - Public lock can only be unlocked with private key 
 - When the user first accessing the https webserver
   - he gets the public key from the server
   - the users browser than encrypts the symmetric key provided by the servers public key
   - Private key is never sent over transit
   - Private key is used to dencrypt 
   
   - Ensure integrity by using Certificates
   - Certificate contains, who the cert is issued too, location 
     - Name on it / Subject 
     - if you assign a certificate, it is called a self signed certificate
     - Cert authority can assign certs
       - Generate CSR 
         - Using open ssl for example
     - Validate information provided 
     - sign and send certificate
     - if hacker tried to validate his certificate, it would fail and be rejected
     
     - How do you know, cert signed by Symantec etc, 
       - They have their own public and private keys pairs
         - private keys to sign certificates
         - public keys hosted in browsers built in, using public key of CA if actually
           signed by CA
           
    - For Internal sites, private links, Private CAs can be hosted on prem, to validate
      private on-prem connections. 
      
    1. To encrypt messages use assymmetric keys
    2. Admin uses pair of keys to connect to servers via ssh
    3. Server uses pair of keys to secure https traffic
    4. server first sends CSR to CA, 
    5. The CA uses its private keys to sign CSR
    6. The signing Certificate is than sent back to the server, 
    7. server than configures web application with new certitificate 
    8. To communicate with client, server first sends its certificate with its public key 
    9. Users browser reads the certificate and uses the CAs public key to validate and retrieve
       the servers public key
   10. Than generates a symmetric key that it wishes to use going forward for communication 
   11. The symmetric key is encrypted using the servers public key and sent back to the server 
        
    12. The server uses its private key to decrypt the message and return the symmetric key
        the symmetric key is used for communication 
    
    How does the server trust the client:
    
    1. The server can request the clients certificate
    2. Client generates pair of keys and signed certificate from a verified CA
    3. Client than sends the client certificate to the server for it to verify the client is 
       who they are
  
    
   Security Kubernetes with TLS:
    
   - Previously we saw a CA, have their own public and private key-pairs to sign server certificates
     this is called a 'root certificate' 
     
   - A server can request a client certificate using client certificates
   - 3 types of certificates Server certificate, Client Certificate, Root certificates 
   - *crt or * pem = public key
   - *key or *key.pem = private key
   
   - K8s cluster containes set of master and worker nodes, communication between all needs to be secure and -
     encrypted 
     
   - Client must secure tls connection to components.
   
   - Kube-API-Server exposes https service, it is a server and request certificate to secure the service.
     generate key pair, called apiserver.crt and apiserver.key
     
   - etcd requires pairs of certificate and key also etcdserver.crt
   - kubelet also requires cert and key pair kubelet.crt
   
   - client or admin requires cert and key pair to authenticate to kube-apiserver
   - kube scheduler talks to the kube-apiserver to look for pods which requires scheduling and get the 
     kube api server to schedule the pods to nodes. 
   - The scheduler is a client act as the kube-apiserver from the kube-apiserver perspective the kube scheduler
     is just another client
     
   - The kube-scheduler needs to valides its identiy using client certificate and key scheduler.crt and key 
   
   - The kube controler manager also requires a client cert and key to validate identity 
   
   - Kube-proxy also requires a cert and key to authenticate to kube-api server 
   
   - Kube-APIServer communicates with the ETCD server is the only one which speaks to the ETCD Server 
     in this case the kube-api-server is the client can either use the existing cert and key or specifically 
     new ones just for communication to the ETCD. 
     
    - The kube-apiserver also communicates with the kubelet thats how it monitors each worker nodes.
      can use orignal cert key or new ones 
   
   
   
   
    
     
     
     
     
     
     
     
 
 
  
  
